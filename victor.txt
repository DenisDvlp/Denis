Foo f;
	auto op = f->*[](){};

класс фу с перегруженой стрелочкой и перегруженным умножением, которое принимает функциональный объект

->* вот это один оператор и его можно перегрузить)
Оператор называется pointer to member



class final { int a } test;

создание экземпляра анонимного класса

Создание экземпляра класса. Но не анонимного. Final это будет тип класса)

Да, но final и override можно использовать как имена
дефолт тоже

Можно написать class final final{}; 


--------------------

class {} test; 

Как унаследоваться от этого класса?

class A: decltype(test){};


--------------------


#include <iostream>

int main()
{
int count = 1;
int сount = 2;
int соunt = 3;
std::cout << "count_1 = " << count << " count_2 = " << сount << " count_3 = " << соunt;
}

C++14 компилиться) 
Ну что выведет в консоль?
333
Не)
1 2 3


почему?
есть объяснение
Это разные переменные. В них есть символы из кириллицы)

Ну короче с++ стал юникодным и ты можешь хоть русскими буквами имена переменных писать

теперь я смогу увидеть с++ на китайском?
Ага)

-----------------------


int i = 10; 
while(i —> 0) {}

он перегружается?
испортили стрелочку

Ну вот это прикол) это скомпилиться, но работать будет так (i —) > 0

Это тоже всегда было))

Просто выглядит так будто стрелка 

----------------------------


#include <vector>

template<typename T>
class Foo : public std::vector<T>
{}

Если бы ты ревьювил, то пропустил бы такой код?

using есть для этого

У всех контейнеров stl нет виртуального деструктора


------------------------

1. В каких случаях может использоваться ключевое слово typename 

1. typename говорит компилятору что сейчас будет тип, например:
template <class T>
void f(){
typename T::T1 t = 10;
}

Viktor 10:06
Да)


----------------------------------
2. template <class T1, T2> 
? sum (T1 param1, T2 param2) { return param1 + param2; } 
Какое должно быть возвращаемое значение?
2. decltype(auto) или auto sum (T1 param1, T2 param2) -> decltype(param1+param2) { return param1 + param2; } 
можно и посложнее завернуть
с && и прочим
forward, stl::declчтототам

Viktor 10:09
Да, есть ещё кстати один вариант)


------------------------------

3. Можно ли подменить таблицу виртуальных функций или отдельную виртуальную функцию?

3. т.к. в классе первыми 4/8 битами идёт указатель на втабл, то можно кастонуть во что-нибудь и тупо заменить memcpy
но на счёт отдельной функции хз

3. нет. ОС не даст заменить что-то в таблице. Но можешь заменить то на что ссылается указатель

То есть создать свою таблицу

Создаёшь массив указателей на функцию
и в указатель на vtable записываешь указатель на твой массив
меняешь значение указателя)

--------------------------

#include <string>
class Base
{
public:
	Base(int a) {};
	Base(int a, float b) {};
	Base(int* ptr, bool val, std::string str) {};

};

class Derrived : public Base
{
public:
};

int main()
{
	Derrived d1(5);
	Derrived d2(5, 5.0f);
	Derrived d3(nullptr, false, "test");
	return 0;
}

Как сделать, чтоб этот код скомпилился и работал?
Изменять базовый класс нельзя

в базовом конструктора по умолчанию нет, т.е. в производном нужно явно описать и вызвать базовый с параметрами
class Derrived : public Base
{
public:
  Derrived(int a) : Base(a) {};
  Derrived(int a, float b) : Base(a, b) {};
  Derrived(int* ptr, bool val, std::string str) : Base(ptr, val, str) {};
};

Как вариант подходит, но не очень красивый

  template<typename... Args>
  Derrived(Args... args) : Base(args)... {};
  
Ооо это уже лучше) Но может быть проблема с перегрузкой)
Есть самый крутой вариант
Но этот тоже хорош)


погоди, я подумаю малость ещё
using Derrived = Base;

Такое даже не скомпилиться)


using Base::Base;
---------------------------


ты слышал про шаблонные переменные?

template<class T>
constexpr T test = T(1);

----------------------------------

struct A
{
	
};

int main()
{
	A::A a;
	return 0;
}

Так можно делать?

11:58
это как бы ты достаёшь конструктор из класса
и потом пишешь а
короче нет, это хуета

struct A
{
	
};

int main()
{
	struct A::A a;
	return 0;
}

а так?

ни разу такой дичи не встречал и разумного объяснения найти не могу

Вот так можно делать, а первый вариант нет)

можешь объяснить что происходит во 2

Создаётся переменная типа А

а зачем впереди стракт?

ну вот такой синтаксис )

Хз зачем)

я не понимаю зачем создавать абсолютно избыточный синтаксис

чтоб больше ясности было наверно

struct A::A a; - так не работает

struct A a; - так работает

у тебя структура объявлена выше?

да

Странно 

struct A::A a; у меня вот так работает

------------------------------

Можно ли делать так?

for(auto it : {1,2,3,4,5})
{
    cout << it << '/n';
}

Давай я тебя наведу на ответ)


не должно отработать
выведением типов занимается авто
тут авто не выводит {}

Отработает) Так даже делать можно)

и бывает даже удобно)

что такое auto ты знаешь, да?

Что такое range-based for знаешь?

std::vector<int> vec;
...
...
...
for(int val : vec){ cout << val;}
Вот это и есть range-based for

То есть он работает с любыми объектами для которых можно вызвать begin и end
только как он преобразовал {} к инитлисту


initialization list это фича с++11. И если ты пишешь {1,2,3,4}, то компилятор это воспринимает как initialization list


template<typename T> void f(T t){}
передай туда {1,2,3,4}
только в отдельных моментах он воспринимает как initialization list
и этот момент когда auto l = {1,2,3,4};
void F(std::initializer_list<int>)
{

}

	F({1,2,3,4});

так работает
а в шаблоне - нет

Viktor 16:31
Ну а причём тут шаблон? В шаблон ты должен явно передать тип. 
А тут тип уже указан

http://ru.cppreference.com/w/cpp/utility/initializer_list

Там в примере есть похожий код)

ок, а в чём неоднозначность {1,2,3,4}?

Viktor 16:32
Ну потому что такой записью {1,2,3,4} ты можешь проинициализировать вектор, массив, свой класс
Вот он и не может определить)

в стандарте сказано что илист в приоритете перед инициализацией классов и прочего

template <typename T>
void F(T t)
{

}
F<std::initializer_list<int>>({1,2,3,4});

достаточно же f(12)

Если сложный шаблон, то нужно писать f<>

-------------------------------

struct Test
{
   void F() && 
    {}
}

Видел такое?

и с одним & видео

------------------------------

Как обернуть конструктор в try-catch


конструктор не должен выбрасывать исключения
Но он может выбросить исключение
может


как и функцию

  try {
    A *a = new A();
  } catch (int e) {}


Окей, это ты обернул и конструктор и создание своего объекта.

А если ты хочешь чтобы обработка эксепшина была внутри класса?

Что бы каждый раз не писать вот так как ты написал


Допустим ты в конструкторе используешь какой-то объект, который при инициализации может кинуть эксепшн

16:47
class A {
public:
  A() noexcept {
    try {
      //might be some error
    }
    catch (int e) {}  
  }
};

ну такое себе


class A 
{ 
 Foo f;
 A() : f(nullptr)
 {}
}

Вот если вот так

f должен выкинуть эксепшн

16:49
ок, понял
ща
class A {
public:
  Foo f;
  A() : f(tryExcept(nullptr)) {}

  Foo tryExcept(void* ptr)
  {
    try {
      return Foo(ptr);
    }
    catch (int e)
    { 
      return Foo(); 
    }
  }
};

нихера себе ты навоял))
слишком сложно))
Ещё и дополнительное копирование)
два раза
там можно оптимизировать шаблоном, ну то детали
ты мне концепт скажи
Ну всё равно будет одно лишнее копирование)
Как бы ты не заоптимизировал
а вообще вот

class A 
{ 
 Foo f;
 A() try : f(nullptr)
 {}
 catch(...){}
}

из того что я знаю, try можно пистаь только внутри функций

-----------------------

Вот так тоже можно

int* ptr = nullptr


int *ptr = nullptr


int * ptr = nullptr


вот варианты
int x = 10, y = 20, *ptr = 0;
void f(int*);

То есть ты объявляешь переменные в одну строку?)

void f(int * ptr){}
я не ставлю в одну строку, но если и поставлю, то сделаю так как написал


Ну странно, люди обычно придерживаются одного стиля, а ты всех сразу))

потому что * не относится к типу, а относится к переменной

Это понятно

Но писать в одну строку это такой себе код-стайл

если кодстайл будет требовать, то могу и в одну строку

а вот такое:

const int a = 5; 

int const a = 5;

1е потому что легко попутать с 
int & const x
или int * const & x

так а кто теме мешает так писать? const int & x

const int   const x
int const   const x

никто, потому и пишу как в 1 варианте
можно и так и так, это зависит от кодстайла
как по мне, то читабельней  и корректней const int
это тогда соответствует спиральному чтению

С точки зрения парсинга второй вариант правильный

http://c-faq.com/decl/spiral.anderson.html
хотя похер, я глянул только что
а мне срать на парсинг, это его проблемы

И на компилятор?)

я всю жизнь пишу const int и ни одна книга ни одна статья не говорит о том что это неправильно
 или менее правильно
 
 Ну так, а если кодстайл тебе скажет?

ну только в этом случае
хз, может даже привыкну и понравится

------------------------------
хочешь немного дичи?


#include<iostream>

int main()
{
  int x=0; //What is wrong here??/
  x=1;
  std::cout<<x;
}

1 выведет

Ну смотри, если юзаем С++11, то 1
А если нет, то выведет 0. Как думаешь почему?

если скомпилишь в студии 2008, то точно будет 0

что может быть не так в записи int x=0;

в ней всё впорядке
и это не баг компилятора
это по стандарту языка

Вот в чём прикол. Есть такая хрень как триграф

??/ замениться на \ 
И то есть вторая строка тоже будет коммент)


кстати на сpp shell это есть даже в С++14

вообще однострочный комментарий должен быть однострочным

Я не говорил, что нужно так писать

как по мне, то я реально перейду на шарпы
нахуя так портить язык
настолько неочевидным стал
одна только мув семантика

Это как раз убрали

Сейчас этого нет

в студии до сих пор работает

у меня в 2015 нет

хоть компилятор и 14
кстати в книгах триграф не описывается
разве что как сноска в дефайнах
или когда строку пишешь
типа char *s = "efrtfww\
fsgdsrg";

так это не триграф

но комментарий должен всё это херить
#define NULL \
0
будет работать

да, но это тоже не триграф

но комментарий(везде пишется) должен игнорировать весь следующий текст
а он получается пропускает функционал компилятора

Денис) То что ты написал это не триграфы. Это просто символ, который обозначает что продолжение строки или дефайна будет на следующей строке)

17:50
ну да
тут получается то же самое

Но помимо этого \ делает однострочный комментарий многострочным

А триграф это вот эта хрень ??/

почитай хинт в компиляторе
6:32: warning: trigraph ??/ converted to \ [-Wtrigraphs]
6:12: warning: multi-line comment [-Wcomment]
конвертировалось в \

??/ - это триграф

--------------------------------

int main()
{
bool a = true;
bool b = false;

if(a or b) std::cout << "A or B";
return 0;
}


что будет?

в с++ or оператора нет
можно самому определить оператор, но такого по умолчанию нет
Как самому определить такой?

та хз, ни разу не делал, наверно так:
operator or (blabla)

В С++ нельзя придумывать свои операторы)
можно суфиксы придумывать
причём тут суффиксы?

я понял
это тупо дефайн

нет)

#define or ||

Вот такой код скомпилиться ничего не добавляя
только инклуд iostream

не компилится

зайди на сайт cpp shell

Потом расскажу чего в студии не компилиться)

https://stackoverflow.com/questions/2393673/c-and-or-not-xor-keywords

по поводу or
я был прав

О чём ты? в чём ты был прав?

#define or ||

Это сделано компилятором, а ты предлагал свой код написать

ответ почему так работает
потому что там дефайн скрывает
свой или встроенный, не важно
без дефайна работать не будет

Всмысле не важно. Это фишка была компилятора. Конкретно стандарт языка, а вот как он реализован вот это уже не важно

в корне лежит дефайн

Не обязательно, компилятор это может реализовать как угодно

------------------------------

как ты предпочитаешь писать?
get(int & t)
get(int&  t)
get(int  &t)

как и указатели рядом с типом

почему так?

Так просто удобнее читать. Ты смотришь на тип и сразу видишь что это ещё и ссылка

т.е. нет никаких оптимизаций парсера и т.п.

нет
пофиг как ты напишешь, эти пробелы не на что не влияют, только на код стайл
Та же фигня и с const. Работать будет одинаково. Просто если ты читаешь код, так же как парсер, то тебе будет удобнее писать int const a;

мне удобней const int

мне тоже

----------------------------

#include <iostream>

int main() 
{
  int a = 0;
  decltype((a)) b = a;
  b++;
  std::cout << a << b;
  return 0;
}

тип b?

int&
знаю такую фигню))

----------------------------


class A
{
public:
  A() { cout << "A\n"; }
  ~A() { cout << "~A\n"; }
};

int main()
{
  A a();
  return 0;
}
скомпилится?
что выведет?

Это объявление прототипа функции)

--------------------------------------


#include <iostream>

struct Foo
{
	Foo() { std::cout << "Foo"; }
};

struct Bar
{
	Bar(const Foo &foo) { std::cout << "Bar"; }
	void f() { std::cout << "f"; }
};

int main()
{
    Bar b(Foo());
    b.f();
}


Что теперь выведет?

---------------------------


Viktor 10:50
class Bar
{
};

class MyTest : public Bar
{
};

int main()
{
Bar b; // ok
MyTest t; //compile error
return 0;
}


Как сделать класс Bar - final? Не используя ключевое слово final. Код можешь модифицировать как хочешь, кроме функции main

11:04
class Bar
{
friend void main();
private: Bar(){}
};

class MyTest : public Bar
{
};

Ну ладно, тогда не много не так) Объект Bar можно везде создавать) Только наследоваться от него нельзя
А то ты прям сильно пошёл)

Давай думай, но на самом деле решение не сложное) 


спасибо за пример
я бы не решил

class Bar;
class Final
{
	friend Bar;
	Final(){}
};

class Bar : virtual Final
{
public:
	Bar(){}
};


class MyTest : public Bar
{
};
я загуглил в итоге
я про виртуальное наледование где-то проебался однажды

Да, так) Можно и без виртуального наследования)
без виртуального компилится


Ну да, оно и работает без виртуального)

-----------------------


Что выведет?

#include <iostream>

int main()  {
    int array[] = { 1, 2, 3 };
    std::cout << (4, (1, 2)[array]) << std::endl;
}

косвенная адресация?

да

выведет 4

Нет)

1. cout выведет результат (4, (1, 2)[array])
2. результат (4, (1, 2)[array]) - это крайний левый аргумент
3. cout выведет 4
как я помню то у выражения (1,2,3,4) результат будет из крайнего левого
но если результат крайний правый, то ответ будет
(4, (1, 2)[array]) - (4, (2)[array]) - (4, *(2+array)) - (4, 3) - (3)
ответ 3
я только что проверил, и результат из круглых скобок  - крайний правый... не знаю почему я запомнил, что крайний левый((

Когда юзается запятая, то левый отбрасывается и используется правый

------------------------
#include <iostream>

struct Foo {
    Foo() { std::cout << "Foo()\n"; }
    Foo(const Foo&) { std::cout << "Foo(const Foo&)\n"; }
    Foo(int) { std::cout << "Foo(int)\n"; }
    Foo(int, int) { std::cout << "Foo(int, int)\n"; }
    Foo(const Foo&, int) { std::cout << "Foo(const Foo&, int)\n"; }
    Foo(int, const Foo&) { std::cout << "Foo(int, const Foo&)\n"; }
};

void f(Foo) {}

struct Bar {
    int i, j;

    Bar() {
        f(Foo(i, j));
        f(Foo(i));
        Foo(i, j);
        Foo(i);
        Foo(i, j);
    }
};

int main() { Bar(); }

Что выведет?


пзц, я сейчас в общем чате холивар начал этим кодом
struct A {
	A(){}
	A(int x){}
};
void main() { 
	int i;
	A(i);
}
error C2371: 'i' : redefinition; different basic types


Ну а в чём холливар?) Ты объявляешь переменную i два раза)

чё за хрень? как это объясняется?

Viktor 17:34
int(i) = int i

Это просто такой синтаксис


объявлением функции меня уже не заманишь
как я её объявляю?

Это не функция. Это объявление интовой переменной с именем i. Всегда так было)
Это так же как с массивами
arr[i] == i[arr]
Вот это с переменной я так понимаю из С пришло


-------------------


 Какой тип у this внутри класса Х, в конст и не конст методах?

в константном const X* ,  в неконстантном X*

this можно перезаписать? 

это rvalue

Ну rvalue ссылку можно перезаписать

const X*const и X*const

Нет)

Первый раз правильно сказал) 

я не проверял перезапись this, но логика мне говорит что нельзя

Нельзя, но он не константный)

было бы лучше если бы был константный, так как это логичней с точки зрения, что его перезаписать нельзя
ну как есть так есть


-----------------------------


#include <iostream>

int main() {
   int n = sizeof(0)["abcdefghij"]; 
   std::cout << n;   
}

Что будет? 

код буквы e

NO

давай начнём так:
1. 0 - это int
4. 5й символ э то "e" и он запишется в int
5. cout выведет n числом на экран, т.к. это int и этим числом будет код "e"
ну и что я не так ответил?

По кусочкам всё правильно, а вот если взять мой код, то всё не так будет)

скорее всего херня в приоритете операций и выведет 4, потому что косвенная адресация отработает позже присваивания

Нет)
Присваивание после всего сработает)

Подсказку?

[] - приоритет 2
sizeof - приоритет 3
= - приоритет 15

Ну вот

= последнее


int n = sizeof(0)["abcdefghij"]; 
int n = *("abcdefghij" + sizeof(0));
это аналог

Говорить ответ? 
да

1

Говорить почему? 

char c = (0)["abcdefghij"];
int n = sizeof c;
Вот это аналог


я всегда думал что sizeof выполняется как функция со скобками
я не думал что она работает без них

https://en.cppreference.com/w/cpp/language/sizeof
Есть оба варианта)


-----------------------------

int i = 21474836480;
bool b1 = 21474836480; // true
bool b2 = i;           // false 

-----------------------------

-42 < 42

int16_t(-42) < int16_t(42); // true
int16_t(-42) < int32_t(42); // true
int32_t(-42) < int16_t(42); // true
int32_t(-42) < int32_t(42); // true

int16_t(-42) < uint16_t(42); // true
int16_t(-42) < uint32_t(42); // false
int32_t(-42) < uint16_t(42); // true
int32_t(-42) < uint32_t(42); // false

uint16_t(-42) < int16_t(42); // false
uint16_t(-42) < int32_t(42); // false
uint32_t(-42) < int16_t(42); // false
uint32_t(-42) < int32_t(42); // false

uint16_t(-42) < uint16_t(42); // false
uint16_t(-42) < uint32_t(42); // false
uint32_t(-42) < uint16_t(42); // false
uint32_t(-42) < uint32_t(42); // false

---------------------------------

  std::cout << std::boolalpha;

  char x = -128;
  std::cout << (x == -x) << std::endl;
  char y = -x;
  std::cout << (x == y) << std::endl;
  
  char x = -127;
  std::cout << (x == -x) << std::endl;
  char y = -x;
  std::cout << (x == y) << std::endl;
 
---------------------------------

чтобы найти точку входа в огромном проекте нужно запустить отладку по F10(Step over - Шаг с обходом).


----------------------------------

  if (x < 1000) result of comparison of constant 1000 with expression of type 'char' is always true
  {}

  if (y > -40000) result of comparison of constant -40000 with expression of type 'short' is always true
  {}
  
  
----------------------------------

  int x[1][5] = { {1,2,3,4,5} };
  auto y3 = x[0][4];
  int** y1 = (int**)x;
  auto y4 = y1[0][4];
  