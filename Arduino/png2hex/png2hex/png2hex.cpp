// png2hex.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//
#include "DImage.h"
#include "DString.h"
#include "ArrayOfExtendedByte.h"
#include <iostream>
#include <bitset>
#include <sstream>
#include <fstream>
#include <filesystem>

using namespace std;
DBiArray<unsigned char> readFont(const DImage& img) {
  DBiArray<unsigned char> output;
  return output;
}

DBiArray<unsigned char> convertToBits(const DImage& img, uint8 threshold) {
  static constexpr size_t BITS_IN_BYTE = 8;
  const DSize imgSize = img.size();
  const int16 widthOut = (imgSize.width() / BITS_IN_BYTE +
    (imgSize.width() % BITS_IN_BYTE ? 1 : 0));

  DBiArray<unsigned char> output;
  output.size(widthOut, imgSize.height());

  bitset<BITS_IN_BYTE> bits;
  for (size_t i = 0, k = 0; i < imgSize.height(); i++)
  {
    for (size_t j = 0; j < imgSize.width(); ++k)
    {
      bits.reset();
      for (int k = BITS_IN_BYTE - 1; k >= 0 && j < imgSize.width(); ++j, --k)
      {
        // Turn colored pixel into grayscale. Use Luma coding Rec. 601:
        //   Y = 0.299 * R + 0.587 * G + 0.114 * B;
        // BRIGHT pixels are 0's (background), DARK pixels are 1's.
        // Brightness is in range of [0, 255].
        // Bright pixels are >=128. Dark pixels are <128.
        const DColor color = img[i][j];
        const double brightness = 0.299 * color.red() + 0.587 * color.green() + 0.114 * color.blue();
        bits.set(k, /*isDark*/ brightness < threshold);
      }
      output.raw()[k] = static_cast<unsigned char>(bits.to_ulong());
    }
  }
  return output;
}

string getExternStructs(string name) {
  string bmpName("bmp_");
  bmpName.append(name);
  string picName("pic_");
  picName.append(name);
  std::stringstream ss;
  ss << 
    "extern const Bitmap " << bmpName << ";\n"
    "extern const Picture " << picName << ";\n\n";

  return ss.str();
}

string getStringArray(const DBiArray<unsigned char>& output, string name) {
  static constexpr size_t HEX_IN_ROW = 12;
  static const char lookupHexTable[] = {
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
  };
  size_t outSize = output.size().square();
  if (outSize == 0) {
    return "";
  }

  // get array of hex values
  string pngName("png_");
  pngName.append(name);
  std::stringstream ss;
  ss << "static const uint8_t " << pngName <<"[" << outSize << "] PROGMEM = {";
  for (size_t i = 0; i < outSize; ++i)
  {
    if (i % HEX_IN_ROW == 0) {
      ss << "\n  ";
    }
    ss << "0x" << lookupHexTable[output.raw()[i] >> 4] << lookupHexTable[output.raw()[i] & 0xF] << ", ";
  }

  // get full structs
  string bmpName("bmp_");
  bmpName.append(name);
  string picName("pic_");
  picName.append(name);
  ss << "\n};\n"
    "static const Bitmap " << bmpName << "(" << pngName << ", "
    << (output.size().width() * 8) << ", " << output.size().height() << ");\n"
    "static const Picture " << picName << "(" << bmpName << ");\n\n";

  return ss.str();
}

bool appendToFile(string filepath, const string& text) {
  if (text.empty()) {
    return true;
  }
  fstream headerFile(filepath, std::ios_base::out | std::ios_base::app);
  if (!headerFile.is_open()) {
    return false;
  }
  headerFile << text;
  headerFile.close();
  return true;
}

DVector<string> readFromFile(string filepath)
{
  fstream imgfile(filepath, std::ios_base::in);
  if (!imgfile.is_open()) {
    return {};
  }
  DVector<string> list;
  string str;
  while (!imgfile.eof()) {
    std::getline(imgfile, str);
    if (!str.empty()) {
      list.push(str);
    }
  }
  imgfile.close();
  return list;
}

int main(int count, const char** args)
{
  if (!filesystem::exists("imglist.txt")) {
    cout << "This program read `imglist.txt`\n"
      "which contains a list of image names. It converts\n"
      "the images into PROGMEM arrays of HEX values\n"
      "suitable for Arduino projects.\n"
      "For instance:\n\nfilepath/img1.png -t200\nimg2.png -t128\n\n"
      "Put -t flag with a following value of the threshold after the image path.\n"
      "All pixels with brightness higher than the given threshold are considered\n"
      "as a background(or white), otherwise those, which are lower than the threshold,\n"
      "are considered as black pixels. The threshold `-t` flag is not mandatory.\n"
      "Default value is 128. The threshold shall be in range of [0, 255].\n\n"
      "Note: image file path shall be without spaces.\n";
    return 1;
  }

  if (count != 2) {
    cout << "Usage: png2hex FILEPATH\n"
      "FILEPATH is a name of two autogenerated files: FILEPATH.h and FILEPATH.cpp";
    return 1;
  }

  auto list = readFromFile("imglist.txt");
  if (list.empty()) {
    cout << "Unable to read `imglist.txt` or file is empty.\n";
    return 1;
  }

  DString headerName = args[1];
  headerName += ".h";
  DString cppName = args[1];
  cppName += ".cpp";
  filesystem::remove(headerName.data());
  filesystem::remove(cppName.data());

  string includes = "#pragma once\n"
                    "#include \"Picture.h\"\n\n";
  appendToFile(headerName.data(), includes);

  includes = "#include \"";
  includes += filesystem::path(headerName.data()).filename().string();
  includes += "\"\n";
  includes += "#include <avr/pgmspace.h>\n\n";
  appendToFile(cppName.data(), includes);

  for (auto& name : list)
  {
    DString s = name;
    // font image found
    bool isFont = false;
    auto it = s.find(" -f");
    if (it != s.end()) {
      isFont = true;
      s.erase(it, it + 3);
      name = s.data();
    }
    // casual image found
    uint8 threshold = 128;
    it = s.find(" -t");
    if (it != s.end()) {
      string t = { it + 3, s.cend() };
      threshold = static_cast<uint8>(std::atoi(t.data()));
      s.erase(it, s.cend());
      name = s.data();
    }
    DImage img;
    if (!img.load(name)) {
      cout << "Unable to read image `" << name << "`. Skipped." << endl;
      continue;
    }
    cout << "Image `" << name << "` read." << endl;

    s.remove(".png");

    if (isFont) {
      DBiArray<unsigned char> output = readFont(img);
      continue;
    }

    DBiArray<unsigned char> output = convertToBits(img, threshold);
    string array = getStringArray(output, s.data());
    if (!appendToFile(cppName.data(), array)) {
      cout << "Unable to write to file `" << cppName.data() << "`." << endl;
      return 1;
    }
    string structs = getExternStructs(s.data());
    if (!appendToFile(headerName.data(), structs)) {
      cout << "Unable to write to file `" << headerName.data() << "`." << endl;
      return 1;
    }
  }
  cout << "Done." << endl;
  return 0;
}